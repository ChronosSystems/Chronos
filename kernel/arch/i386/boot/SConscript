# We need to manually define dependencies for boot image.
# TODO: Make a better way to configure this than editing a python data
# structure.
Import('KERNEL_DIR')
Import('ARCH_DIR')
Import('arch_env')
Import('REAL_CURDIR')

BOOT_DEPS = {
        'boot-stage1': {REAL_CURDIR():['stage1/ata']},
        'boot-stage2': { 
            ARCH_DIR: [
                'lock/stdlock',
                'vm/asm',
                'vm/pgdir',
                'vm/vm_alloc',
                'vm/vm_boot',
                'drivers/serial',
                'drivers/ata',
                'drivers/pic',
                'x86/asm',
                'src/cpu'
                ],
            KERNEL_DIR:[
                'drivers/diskio',
                'drivers/ext2',
                'cache/cache',
                'cache/diskcache',
                'cache/cacheman',
                'stdlock',
                'file',
                'stdlib'
                ],
            REAL_CURDIR():[
                'stage1',
                'stage2',
                'stage2_jmp'
                ]
            },
        'multiboot':{
            REAL_CURDIR():[
                'multiboot/multiboot',
                'multiboot/multiboot_header',
                'stage1',
                'stage2',
                'stage2_jmp'
                ]
            }
        }

COMMON_BOOT_DEPS = {}

STAGE_BUILD_SETTINGS = {
        'boot-stage1': {
            'LDFLAGS': [
                '--section-start=.text=0x7c00',
                '--entry=start'
                ]
            },
        'boot-stage2': {
            'LDFLAGS': [
                '--entry=main',
                '--section-start=.text=0x7E00',
                '--section-start=.data=0x17E00',
                '--section-start=.rodata=0x18600',
                '--section-start=.bss=0x18e00'
                ]
            },
        'multiboot': {}
}

COMMON_BUILD_SETTINGS = {'CCFLAGS': [
    '-D__BOOT_STRAP__'
    ]
    }

def apply_common(stage_dict, common_dict):
    for stage, stage_setting_dict in stage_dict.items():
        for common_setting in common_dict:
            if common_setting not in stage_setting_dict:
                stage_setting_dict[common_setting] = []
            stage_setting_dict[common_setting].extend(common_dict[common_setting])

# Apply the common build settings.
apply_common(STAGE_BUILD_SETTINGS, COMMON_BUILD_SETTINGS)
#apply_common(BOOT_DEPS, COMMON_BOOT_DEPS)

def build_dependencies(boot_stage):
    built_objects = []
    for source_dir, depslist in BOOT_DEPS[boot_stage].items():
        for depfile in depslist:

            # Take the file from the source_dir NOT of the variantdir
            files = Glob(Join_path('#'+source_dir, depfile+'.[c|S]'))

            # NOTE: If there is both an .S and a .c file of the same name and location
            # we'll need to improve this logic.
            if files is not None:
                for file_ in files:
                    built_objects.extend(boot_env.Object(boot_object_name(stage,depfile), file_))
    return built_objects

def boot_object_name(stage, file_):
    return Join_path(stage,file_)

# Build each stage.
for stage in BOOT_DEPS: 
    # Build each boot sector in it's own build directory.
    VariantDir(stage, REAL_CURDIR(), duplicate=0)

    boot_env = arch_env.Clone()
    boot_env.Append(**STAGE_BUILD_SETTINGS[stage])

    objs = build_dependencies(stage)

    boot_obj = boot_env.Ld(stage+'.o', source=objs)

    #boot_env.Objcopy(stage+'.img', boot_obj)
