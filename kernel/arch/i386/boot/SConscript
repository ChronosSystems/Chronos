# We need to manually define dependencies for boot image.
# TODO: Make a better way to configure this than editing a python data
# structure.
import subprocess

Import('KERNEL_DIR')
Import('ARCH_DIR')
Import('arch_env')
Import('REAL_CURDIR')

BOOT_STAGE1 = 'boot-stage1'
BOOT_STAGE2 = 'boot-stage2'
MULTIBOOT   = 'multiboot'

LOAD_STAGES = {BOOT_STAGE1, BOOT_STAGE2}

BOOT_DEPS = {
        BOOT_STAGE1: {
            },
        BOOT_STAGE2: { 
            ARCH_DIR: [
                'lock/stdlock',
                'vm/asm',
                'vm/pgdir',
                'vm/vm_alloc',
                'vm/vm_boot',
                'drivers/serial',
                'drivers/ata',
                'drivers/pic',
                'x86/asm',
                'src/cpu'
                ],
            KERNEL_DIR:[
                'drivers/diskio',
                'drivers/ext2',
                'cache/cache',
                'cache/diskcache',
                'cache/cacheman',
                'stdlock',
                'file',
                'stdlib'
                ],
            },
        MULTIBOOT:{ # Copy all our sources from boot-stage2
            }
        }

ORDER_DEPENDANT_DEPS = {
        BOOT_STAGE1: [
                ('stage1', REAL_CURDIR()),
                ('stage1/ata', REAL_CURDIR()),
            ],
        BOOT_STAGE2: [
                ('stage2', REAL_CURDIR()),
                ('stage2_jmp', REAL_CURDIR()),
                ('stage1', REAL_CURDIR()),
            ],
        MULTIBOOT: [
                ('multiboot/multiboot', REAL_CURDIR()),
                ('multiboot/multiboot_header', REAL_CURDIR()),
                ('stage2', REAL_CURDIR()),
                ('stage2_jmp', REAL_CURDIR()),
                ('stage1', REAL_CURDIR()),
                ]
        }

COMMON_BOOT_DEPS = {}

STAGE_BUILD_SETTINGS = {
        BOOT_STAGE1: {
            'LDFLAGS': [
                '--section-start=.text=0x7c00',
                '--entry=start'
                ]
            },
        BOOT_STAGE2: {
            'LDFLAGS': [
                '--entry=main',
                '--section-start=.text=0x7E00',
                '--section-start=.data=0x17E00',
                '--section-start=.rodata=0x18600',
                '--section-start=.bss=0x18e00'
                ],
            },
        MULTIBOOT: {}
}

COMMON_BUILD_SETTINGS = {'CCFLAGS': [
    '-D__BOOT_STRAP__'
    ]
    }

BOOT_SEGMENTS = {
        '.text':(0,128), 
        '.data':(128,4), 
        '.rodata':(132,4), 
        '.bss':(136,4)
        }

def apply_common(stage_dict, common_dict):
    for stage, stage_setting_dict in stage_dict.items():
        for common_setting in common_dict:
            if common_setting not in stage_setting_dict:
                stage_setting_dict[common_setting] = []
            stage_setting_dict[common_setting].extend(common_dict[common_setting])

def copy_dependancies(source_stage, dest_stage):

    for dir_, deplist in BOOT_DEPS[source_stage].items():
        if dir_ not in dest_stage:
            deps_in_dest = []
        else:
            deps_in_dest = BOOT_DEPS[dest_stage]

        union = list(set(deplist) or set(deps_in_dest))

        BOOT_DEPS[dest_stage][dir_] = union

copy_dependancies(BOOT_STAGE2, MULTIBOOT)

# Apply the common build settings.
apply_common(STAGE_BUILD_SETTINGS, COMMON_BUILD_SETTINGS)
#apply_common(BOOT_DEPS, COMMON_BOOT_DEPS)

def build_dependencies(boot_stage):
    built_objects = []

    def build_dep(source_dir, depfile):
        # Take the file from the source_dir NOT of the variantdir
        files = Glob(Join_path('#'+source_dir, depfile+'.[c|S]'))

        # NOTE: If there is both an .S and a .c file of the same name and location
        # we'll need to improve this logic.
        if files is not None:
            for file_ in files:
                built_objects.extend(boot_env.Object(boot_object_name(boot_stage,depfile), file_))

    # Build the order dependenant files first so they are listed and thus loaded first.
    for (dep, source_dir) in ORDER_DEPENDANT_DEPS[boot_stage]:
        build_dep(source_dir, dep)

    for source_dir, depslist in BOOT_DEPS[boot_stage].items():
        for depfile in depslist:
            build_dep(source_dir, depfile)

    return built_objects

def boot_object_name(stage, file_):
    return Join_path(stage,file_)


def dd_boot_stage2(target, source, env):

    dd_command = 'dd if={infile} of={outfile} bs={bs} count={count} seek={seek}'

    for file_ in source:
        print('here')
        segment = File_extension(file_.abspath)

        (seek, count) = BOOT_SEGMENTS[segment] 

        dd_args = {
                'infile': file_.abspath,
                'outfile': target[0].abspath,
                'bs':str(512),
                'count': count,
                'seek': seek
                }

        command = dd_command.format(**dd_args).split(' ')
        subprocess.call(command)


def create_boot_stage2_img(env):

    segment_objs = []

    for (segment, (segment_start, segment_length)) in BOOT_SEGMENTS.items():

        env = env.Clone(OBJCOPYFLAGS=['-O binary', '-j '+segment])

        objcopy_target = BOOT_STAGE2 + segment

        objcopy_target = env.Objcopy(target=objcopy_target, source=built_stages[BOOT_STAGE2])

        segment_objs.extend(objcopy_target)

    Dd = Builder(action=dd_boot_stage2)

    env = env.Clone(BUILDERS = {'Dd': Dd})

    env.Dd(target=BOOT_STAGE2+'.img',   source=segment_objs)

STAGE_CALLBACKS = {
        BOOT_STAGE2: [create_boot_stage2_img]
        }

built_stages = {}

# Build each stage.
for stage in BOOT_DEPS: 
    # Build each boot sector in it's own build directory.
    VariantDir(stage, REAL_CURDIR(), duplicate=0)

    boot_env = arch_env.Clone()
    boot_env.Append(**STAGE_BUILD_SETTINGS[stage])

    objs = build_dependencies(stage)

    if stage in LOAD_STAGES:
        boot_obj = boot_env.Ld(stage+'.o', source=objs)
    else:
        # Special case made for multiboot (need to create a .o with CC) 
        boot_obj = boot_env.Program(stage+'.o', source=objs)

    built_stages[stage] = boot_obj

    for callback in STAGE_CALLBACKS.get(stage, []):
        callback(boot_env)
